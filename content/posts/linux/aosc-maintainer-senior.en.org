#+TITLE: Way to AOSC OS Maintainer: Advanced Techniques
#+DESCRIPTION: This article is also sponsered by Commit-O-Maticâ„¢
#+DATE: 2020-02-17T00:00:00
#+TAGS[]: linux
#+STARTUP: indent
#+TOC: true
#+LICENSE: cc-sa

#+BEGIN_QUOTE
So you want to make a package, you've got the urge to make a package, you've got the nerve to make a package, so go ahead, so go ahead, so go ahead and make a package we can use!
#+END_QUOTE

After learning the [[aosc-maintainer-basic.en.org][basics]] about building packages, we can now start exploring some advanced techniques.

Pleaese note that you don't have to read this documentation word-by-word, as it should serve as a point of reference for your future work. Just take a quick look, remember these concepts, and come back when you encounter a problem.

* Advanced Operations in ~Autobuild3~
We've already seen that in many packages, ~Autobuild3~ can automatically determine the build system used in the source tree, then generate and execute build scripts accordingly. But there are many (complex or primitive) programs that require more steps to build and install, or they may require specific build parameters and compiler flags.

We will now introduce how to deal with these issues in AOSC OS's build system.

** Manually Select Different Build Systems
Sometimes, ~Autobuild3~ may make wrong assumptions about the build system, and this would probably result a build failure. In other cases, when building projects where multiple build systems are avaliable, it may not select the optimal one (for build time or reliability).

In this case, we can manually specify which build system to use by defining =ABTYPE== in the ~autobuild/defines~ file.

Currently, these build types are supported:

+ =self= : when a autobuild/build file is provided, uses user created autobuild/build as build script.
+ =autotools= : generally used for GNU autotools-based source trees, with an available configure script in source root, or defined $configure script.
+ =cmake= : used for CMake-based source tree, generates and executes Makefiles, Autobuild3 detects for CMakeList.txt in the source trees.
+ =cmakeninja= : same as above, but generates and executes Ninja build scripts.
+ =waf= : used for Waf-based source tree, Autobuild3 detects for waf file/script in the source trees.
+ =plainmake= : used for source trees with a written Makefile, and therefore is able to be built with make command.
+ =haskell= : used for standard Haskell Cabal/Hackage source trees, comes with a set of scripts that provides Haskell package management functions like registering and unregistering.
+ =perl= : used for standard CPAN source trees.
+ =python= : used for standard PyPI source trees.
+ =qtproj= : used for Qt projects with .pro files in the source trees.
+ =ruby= : used for RubyGems source trees.

** Custom Build System/Compiler Parameters
~Autobuild3~ integrates a list of optimal build parameters. However, sometimes these parameters are not entirely compatible with the software and may cause troubles. In this case, have a look at [[https://github.com/AOSC-Dev/autobuild3/blob/master/etc/autobuild/ab3_defcfg.sh#L105][Autobuild3's default parameters]], and override them accordingly. A complete list of parameters can be found at the [[https://github.com/AOSC-Dev/aosc-os-abbs/wiki/Autobuild3][Autobuil3 Wiki]].

One problem that stands out is LTO (or Link Time Optimization). This technique can improve run-time efficiency and reduce the size of the binary, but for now enabling LTO may result build failure (the number is constantly decreasing), and consumes a lot of RAM during build-time. Autobuild3 uses LTO by default on AMD64 for its improved efficiency, but if you encounter LTO related issues, you can disable it via adding ~NOLTO=1~ in ~autobuild/defines~.

** Custom Build Scripts
In some cases, the software uses a special build system (or they don't need a build system at all, like pre-built binaries). In this case, you may take control over the build process by writing build scripts in Bash.

The build script is located in ~autobuild/build~. If this script exists, the build type will be locked to ~self~ (unless otherwise overriden if another =ABTYPE== was defined), which means =Autobuild3= will not try to determine the build system and execute its integrated build script, but simply execute this script.

This script should look very similar to what you would do to manually compile programs. But one key difference is that you should *NOT* install the compiled program to the system root directory. Instead, it should be installed in ~$PKGDIR~, where later ~Autobuild3~ will make the deb based on the file inside this directory. For example, if the compiled binary is called ~hugo~ in the root of the build directory, you should install it to the ~bin~ directory of the package by:

#+BEGIN_SRC bash
abinfo "Installing Hugo binary..."
install -Dvm755 hugo "$PKGDIR"/usr/bin/hugo
#+END_SRC

Notice that we used a simple function to print log information to the build log called ~abinfo()~. Just call ~abinfo "Desired build infomation"~ in the script, and it will be recorded into the build log. It is considered a good practice to use ~abinfo()~ as a way to comment your build scripts, as this could be beneficial for maintainers who may come after.

** Post-Build Tweaks
Sometimes ~Autobuild3~ handles the build process just fine, but the finished product may need some extra tweaks (i.e: wrong directory for man pages, shell completion scripts need to be copied into the ~$PKGDIR~, and so on). In this case, we use the ~autobuild/beyond~ script, which, like ~autobuild/build~, is executed as a plain Bash script. It will be executed after the build process.

This is an example taken from ~TREE/extra-web/aria2~. Here, we need to install =aria2c='s bash_completion file, so we use the ~autobuild/beyond~ script.

#+BEGIN_SRC bash
install -dv "$PKGDIR"/usr/share/bash-completion/completions
install -vm644 "$PKGDIR"/usr/share/doc/aria2/bash_completion/aria2c \
    "$PKGDIR"/usr/share/bash-completion/completions
#+END_SRC

** The ~autobuild/override~ Directory
Sometimes the source code does not contain (or contain an inappropriate version of) some files needed for the package. In this case, we can place files in the ~autobuild/override~ directory. Notice that files need to be put in their respective directory (as though they are installed in ~$PKGDIR~.

For example, if we are building a package called =foo= and it does not contain the ~.desktop~ file needed for desktop environments in the source tree, we can just write our own ~.desktop~ file and place it in: 

#+BEGIN_SRC 
autobuild/overrides/usr/share/applications/foo.desktop
#+END_SRC

** Advanced Patch Management
We've already learned in the [[aosc-maintainer-basic.en.org][Basics]] that we can patch the source code by simply placing patches inside the ~autobuild/patches~ directory. But sometimes the patches has to be applied in a specific order in order to work.

To mitigate this issue, we introduced the ~autobuild/patches/series~file. This file contains an ordred list of the names of the patches (one filename per line). If this file is present, ~Autobuild3~ will apply patches as specified in the list.

In some other cases, the patches will not apply if they are not on a strip level of 1 (one). Here below is an example header from a strip level 1 patch:

#+BEGIN_SRC 
--- a/kernel/init.c
+++ a/kernel/init.c
#+END_SRC

But sometimes, sources may come in different strip levels, for instance, this patch with a strip level of 3:

#+BEGIN_SRC 
--- dev/working/jelly/kernel/init.c
+++ dev/working/lion/kernel/init.c
#+END_SRC

In this case, you would need to write your own ~autobuild/patch~, which is also a plain Bash script, call your own ~patch~ commands from the script.

* Dealing with Package Groups
When maintaining packages, it is common that a batch of packages (for example, KDE Applications) need to be updated and/or built together. It would be frustrating if we have to manually change the version number and checksum.

So, there are several automation tools written by our maintainers to simplify this process. We will try to update all packages to the latest _patch releases_ in ~TREE/extra-gnome~ here.

** Update Version Numbers, Automatically
First, we have the [[https://github.com/AOSC-Dev/piss][PISS (Project Information Storage System)]] [fn:PISS], which monitors package updates from upstreams and provides an API that obtains and analyzes these information.

[fn:PISS] A great name, I know...

In order to actually utilize these information, there is a tool called [[https://github.com/AOSC-Dev/scriptlets/tree/master/findupd][findupd]], which automatically downloads the infomation from =PISS= and change the corresponding version in package's ~spec~ file. Simply clone the repository, copy all executables and Python scripts into your ~PATH~, and trigger:

#+BEGIN_SRC bash
cd TREE/
findupd-stable extra-gnome
#+END_SRC 

Then, have a look at ~git diff~, you should be able to see a bunch of changes on various of ~VER~ and ~REL~ lines.

If you are dealing with major version bumps, use ~findupd~ instead of ~findupd-stable~.

** Update Checksums, Automatically
This is not enough, however. Although the ~VER~ has been modified, the checksum defined under ~CHKSUM=~ is still for the old tarball, and since it does not match with the actual checksum for the new tarball, ACBS will refuse to process the tarball.

There's also ways to automate this process, but there's not a standard script yet. However, at least one maintainer uses the following method:

#+BEGIN_SRC bash
cd TREE/
# First, generate a temporary group.
git --no-pager diff --name-only | grep spec | sed 's/\/spec//' > groups/gnome-changes
# Use addchksum.py to generate a patch of all the checksums
for i in `cat groups/gnome-changes`; do; python3 ../abbs-meta/tools/addchksum.py $i/spec 2> dev/null\ndone > checksums.patch
# Then, apply the patch
patch -Np0 -i checksums.patch
#+END_SRC

Another (down right dirty) implementation exists, which does not involve creating any temporary files in the repository (this should be merged into our [[https://github.com/AOSC-Dev/scriptlets][~scriptlets~]] repository:

#+BEGIN_SRC bash
#!/bin/sh
for i in `git status | grep modified | grep /spec | awk '{ print $2 }'`; do
    python3 ../abbs-meta/tools/addchksum.py $i
done | patch -Np0 -i -
#+END_SRC

After this, checksums should be up-to-date.

** Build Updates, Automatically
Then we can try to build the new packages. This should be as simple as:

#+BEGIN_SRC bash
cd ciel/ # Enter ciel root directory
ciel build -i INSTANCE groups/gnome-changes
#+END_SRC

** Commit Changes, Automatically
If all packages are built successfully, we can go ahead and commit our changes. Our [[https://github.com/AOSC-Dev/scriptlets/tree/master/commit-o-matic][commit-o-matic]] will accomplish just that. Similar with ~findupd~, simply download the script, put it into your ~PATH~, invoke the script, and bob's your auntie.

Note that if any extra modification was needed, you must note the said modifications in the git log. That said, before invoking ~commit-o-matic~, you should first remove the modified package from the temporary group, and commit it manually.

#+BEGIN_SRC bash
commit-o-matic.sh groups/gnome-changes
#+END_SRC

** Push Changes, Automatically
Finally, we can push the built packages to the main repository.

#+BEGIN_SRC bash
pushpkg LDAP_IDENTITY BRANCH
#+END_SRC

Note that ~IDENTITY~ and ~BRANCH~ are by definition users and repositories on our [[https://repo.aosc.io/][Community Repository]]. Contributors are audited before an LDAP identities are granted by our Infrustructure Work Group - we will get in touch with you via your first PR to our ABBS tree.
